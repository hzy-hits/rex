# 24-09-13 (scribe: Jinghao)

[[Slides](https://docs.google.com/presentation/d/1F3JTY6pDPSJaW4ZFzKcG-9KTGtJjTP9bjwG2Xus7zt0/edit?usp=sharing),
[Recording](https://illinois.zoom.us/rec/share/jMIw1NkPRQejFnEGC5wWXRZZ4gDHtPwGLAfUR8ol3fgM5M-gQhmgv-_haHefpWgm.czt91Yb_7H007f0L)]

### Where we are
- New machine for experiment is ready
- Termination:
  - The use of a regular timer (`struct timer_list`) does not work for softirq
    - Timer interrupt does not fire, probably due to softirqs from timer get
      queued.
  - Potential solution: high resolution timers (`struct hrtimer`)
    - Can run in hardirq
    - Two things to figure out:
      - How to deal with the same CPU case, as `hrtimer`s cannot be migrated
        between CPUs easily
      - Sending IPI from hardirq risks deadlocks, as per kernel warning
- Rex Failure model
  - Previously discused two ways to handle program crashes:
    - Continue allowing other instances to run
    - Detach and remove all related programs and maps
  - New "middle ground" implementation: send a core-dump signal to loader
    - If unhandled, effecitvely forces loader to dump core and remove userspace
      references to the rex objects (e.g., programs, maps)
    - Alternatively loader can try to handle to signal and perform recovery
    - Problem: The recovery may not be reliable, as it is implemented by the
      user
  - Current plan: note in the paper that by default we remvoe all related
    programs and maps

### Next step
- Finish termination
- Rerun experiment

# 24-09-06 (scribe: Jinghao)

[[Slides](https://docs.google.com/presentation/d/1x9eB45MpkaFqxvVSZnJ9IRYEHbDp7P5NrW37OeVVWl0/edit?usp=sharing),
[Recording](https://illinois.zoom.us/rec/share/Qvyye3k4oL9VFppgo8cqiAm0p1H4qiNhMCT5-xk9EOI89LGgI8Z3DZ5yZsOcy8y0.Eo8_KU7TO9sYZVO3)]

### Where we are
- We implemented **program termination** support for Rex programs
  - Based on Raj's previous IPI-based implementation
    - Works by sending an IPI to the CPU that runs the program
    - Resets `%rip` to the `__rex_handle_timeout` to trigger a panic
    - Handles helper calls by deferring termination after helper call
      returns
      - This is because kernel code is not unwind safe
  - Needs to efficiently and automatically trigger the termination - use a
    watchdog timer
    - Armed at boot time and runs periodically
    - Each time the timer fires, the timer handler function checks each
      online CPU for long running programs
      - Works by comparing the program start time (in a per-CPU variable)
        to the current `jiffies` time
      - If runtime exceeds threshold (same as timer period, currently 20s),
        send an IPI to the target CPU
    - Does not work if timer and program are on the same CPU
      - Under this case the IPI function is called synchronously, which
        does not provide the register information of the program
      - Solution: makes the timer rotate on each online CPU
      - Program will be terminated the next time the timer triggers on a
        different CPU
  - Limitation:
    - Cannot handle programs in hardirq
- The failure model of Rex programs
  - Failures in Rex may not happen synchronously
    - In contrast, errors in BPF mostly come from helper function return
      values
    - When error occurs, what the program was doing at that time will
      always be completed
    - In Rex, the data the program touched may not be consistent (in order
      words, make sense for that particular application)
  - Shall we implement failure stop and cleanup all related data (programs,
    maps, etc)
  - Or shall we just let the application to handle it and decide how to
    continue?

### Next step
- Setup the new machine and rerun experiments
- Take a look at the programs running in hardirq
- Think about the failure model of Rex programs

# 23-08-28 (scribe: Jinghao & Ruowen)
### Where we are
- Ruowen finished direct packet access in Rust
  - Basic idea: ensure the struct type that the user wants to transmute to
    has safe field types (i.e. integers). This can prevent the user from
    reinterpreting packet data into arbitrary pointers.
  - The types are marked with the `DirectPacketAccessOk` trait. This trait
    uses the sealed-trait pattern, so that implementation of the trait is
    only possible within the runtime crate.
  - The actual transmute code is generated by a `proc_macro` directive. It
    generates the calls to `direct_packet_access_ok<T:
    DirectPacketAccessOk>()` for each of the struct members followed by a
    `unsafe transmute`. In this way if there is type that does not
    implement the trait the type check will fail.
  - A more detailed documentation will be out shortly.
  - This might be generalized to use cases other than direct packet access
- During compile time, the new linter flag `-Funsafe_code` has been added,
  which prevent user programs from utilizing the unsafe block.
  - This flag also blocks `#[link_section ...]`, so the new `proc_macro` is
    used to generate link section blocks.
- Jinghao is working on documenting the interesting design decisions and
  techinical details (checkout the [docs](.) directory).

### Next step
- Ruowen will continue working on BMC, as the XDP framework is mostly
  finished for now

- Jinghao will continue the documentation process and will take a look at
  the stack overflow protection. Some basic thoughts are detailed
  [here](./EH.md#kernel-stack-overflow)


# 23-08-03 (scribe: Ruowen)

### Where we are
- Now the program can deal with the normal tcp/udp packet from rx_queue
    - currently we use unsafe read_unaligned() method to convert buffer into tcp/ip header struct
- Start to implement tx_queue which usea a different BPF type rather than normal XDP


### Next step
When we convert our BPF program in to our current rust inner-unikernel program, in the below situation, we have to use the unsafe rust
- call kernel helper functions
- read kernel variables and re-borrowing
- convert buffer into network header type like TCP
	- Ruowen aims to accomplish this through 'safe Rust', instead of directly converting variable types

The BPF program permits directly convert the void pointer into different struct, with the BPF verifier ensuring that kernel memory remains uncorrupted. However, this mechanism does not validate the BPF program itself. A case in point is when a BPF program transmutes the void pointer into a incorrect type of struct, this action would pass the verifier and load into kernel but this program would not work as expected due to the inherent 'unsafe' logic.

Our Rust kernel extension seeks to enhance expressiveness and potentially avert such circumstances.

# 23-07-27 (scribe: Ruowen)

### Where we are
- Run benchmark on BMC with both SR-IOV VM and qemu user network VM
    - Performance gain is not that significant
    - SR-IOV VM, 1 million request, key size 12 value size 12
        - Without BMC
            - ~130 seconds
        - With BMC
            - ~95 seconds
    - Qemu user network VM, 1 million request, key size 12 value size 12
        - Without BMC
            - ~30 seconds
        - With BMC
            - ~19 seconds
- Add a draft xdp implementation in rust kernel extension
    - program doesn't work ...

### Next step
- Fix xdp framework and makes it works on simple scenario (like rx).


# 23-07-20 (scribe: Ruowen)

### Where we are going
- Modify BMC to function on qemu with kernel 5.15
    - https://github.com/xlab-uiuc/bmc-cache
- Develop a new memcached benchmark due  to specific testing needs
    - Existing benchmark fails to meet requirements
        - UDP (Unsupported by memtier/memslap)
        - ASCII code
        - High load
        - Restrictions on key and value sizes
    - Hence, we're creating our own.
        - Rust
        - Asynchronous and thread-safe (using tokio)
        - Higher stress than the C-based memslap
    - https://github.com/xlab-uiuc/memcached_benchmark

### Next step
- Ruowen will take a look for BMC on a baremetal host
- Rewrite BMC into current rust kernel extension

# 23-07-06 (scribe: Jinghao)

### Where we are going
We decided to re-position our work

- The security issue is raise repeatedly at HotOS (large TCB from Rust toolchain)
    - Aim for privileged context
- We are going to shift away from the safety argument – the current way of rewriting helpers will produce error-prone and un-maintainable code
  - unclear boundary between Rust and kernel C (e.g., why `task_struct` support in Rust)
  - Code duplication
  - needs to keep exactly the same semantics with kernel C code
  - trouble during kernel upgrades
- Instead, we stick to the current helper interface
  - directly invoking C in Rust wrappers
  - if the computation is local, we will do it entirely in Rust (e.g., loop, `strncmp`, checksum computation)
- The expressiveness will be our focus at this point
  - systematically articulate the current eBPF limitations
  - can we use Rust to solve these? (answer is probably “some of them”)
  - Example limitations
    - Rust extension could solve the missing unbounded loop in BPF
    - Rust extension may not allow us to implement advanced data structures (like B-Trees) given that we do not have dynamic allocation
### Next step
- Create a list of abstract eBPF limitations
  - For each of these create an eBPF program to show the difficulty
  - Also write a Rust program to see if we can solve them
- Ruowen will also take a look at BMC
- Jinghao will take a look at the termination mechanism



# 23-06-29 (scribe: Ruowen)




### Where we are

Rewrite ebpf helper function (most function wrapper)

-   bpf_map_pop_elem
-   bpf_map_peek_elem
-   bpf_for_each_map_elem
-   bpf_spin_lock
-   bpf_spin_unlock
-   cgroup helper function
    -   bpf_sysctl_get_name
    -   bpf_sysctl_get_current_value
    -   bpf_sysctl_get_new_value
    -   bpf_sysctl_set_new_value
-   bpf_strtol
-   bpf_strtoul (we could use something like str.parse)
-   bpf_snprintf




### Where we are going

We need to implement key application to help evaluate expressiveness as kernel kernel extension rather than just talking about trust model.

1.  runtime protection
    1.  WIP
2.  key application
    1.  BMC
        1.  <https://www.usenix.org/conference/nsdi21/presentation/ghigoff>
    2.  XRP
        1.  <https://www.usenix.org/conference/osdi22/presentation/zhong>
    3.  Electrode
        1.  <https://www.usenix.org/conference/nsdi23/presentation/zhou>
3.  helper functions
    1.  wrappers
    2.  pick required networking helper functions to implement BMC.




# 23-06-15 (scribe: Ruowen)




### Where we are

-   Rewrite ebpf helper function
    -   bpf_ktime_get_coarse_ns()
    -   bpf_get_prandom_u32()
-   Add new function for barrier() and update read_seqcount_latch_retry()
    -   Rewrite read_seqcount_latch_retry() function, so we don't need wrap function inside kernel source code
    -   Directly use get_random_u32() rather than get_random_u32_state() <https://lore.kernel.org/lkml/87edtctz8t.fsf@toke.dk/T/> . But this new implementation have performance drawback (a little bit, 38 cycles vs 25 cycles)
    -   Currently memory barrier uses core::sync::atomic::{compiler_fence, Ordering}




### Where we are going

-   We should aim to eliminate unnecessary kernel interfaces by implementing the relevant code directly in Rust.
    -   Since we have implmented task_struct in helper function, we could just use task sturct directly rather than use call kernel interface mutiple times.
    -   We'll use a breadth-first approach, try to implment ebpf helper function without touching inside kernel code, and see which ebpf functions could be elimiated.




# 23-06-08 (scribe: Ruowen)




### Where we are

-   Rewrite eBPF helper functions: `ktime_get_mono_fast_ns()` and `ktime_get_boot_fast_ns()`.
-   Added a Rust implementation for `READ_ONCE` macro in kernel.




### Where we are going

-   Adopting reduction perspective, we're aiming to assume no existing eBPF helper functions and construct our own Rust versions.
-   Current Standard
    -   If using Rust over C doesn't offer substantial benefits, we need to justify why it's the case.
    -   For extremely difficult task, like rewriting a complicated inline function or macros, also requires a compelling reason to proceed.
    -   Attempt to minimize addition of unsafe code in the kernel by rewriting kernel inline function and macro in Rust.
        -   Rewrite `read_seqcount_latch_retry()` function.




# 22-05-17 (scribe: Jinghao)




### Where we are

-   `bpftool` displays correctly the run count of eBPF programs, so it could be
    used for debugging
-   We can now reliably trigger the XDP hook (thanks to Dan's sharp intuition),
    the reason we previously cannot trigger the hook is that YiFei's `q` script
    uses virtual network by default and packets simply does not go through the
    NIC.




### Where we are going

-   Sayeed will continue working on the BMC experiment
-   I (i.e. Jinghao) might spend some time looking in the the `clang` issue by
    checking the code generated after each `llc` CodeGen pass.




# 22-05-20 (scribe: Jinghao)




### Where we are

-   BMC
    -   The code passes the verfier using clang-9
    -   We might want to know why it is failing the verifier when using the lastest
        llvm-toolchain, but looks like it would take too much time.




### Where we are going

-   Run BMC
    -   Setup memcached and run some benchmark
    -   e.g. [memtier_benchmark](https://redis.com/blog/memtier_benchmark-a-high-throughput-benchmarking-tool-for-redis-memcached/)
-   We want to draw a graph that when we gradually increase the data size we get
    a sudden degradation in performance because the eBPF program cannot process
    such a large data size.
-   Summer plan:
    -   After talking to Tianyin, I (i.e. Jinghao) agree with him that I should
        spend most of my time on the internship project. I will still help on our
        project during the summer but probably will only be able to do discussion /
        code fix stuff.
-   misc: This is a good read and I think it is kinda related to our porject (I
    have already sent it to our channel).
    <https://www.bunniestudios.com/blog/?p=6375>




# 22-04-29 (scribe: Sayeed)

-   Sharing maps among multiple programs
    -   The way eBPF does it
        -   Different functions in different sections, all code in same file
    -   Our implementation
        -   We were loading different programs (functions) separately, which could not share maps
        -   It is possible to put different functions in different sections in Rust, just like eBPF
        -   But it would still need `_start` function to compile properly
        -   Absence of `_start` function results in dead code
        -   Turning off dead code in compiler is not an option
        -   So we keep `_start` function just as a placeholder, but it is never executed
        -   Other functions are executed using offsets to the sections
-   Security model
    -   There are existing attacks that exploit current eBPF, like transient execution attacks
    -   Our current implementation may not have the protection, that SMAP provides
    -   We need to explore the implications of the absence of SMAP
    -   So in the context of security, the question that needs to be answered:
        -   Are we making it worse than eBPF, keeping at the same level as eBPF, or making it better?
-   BMC
    -   The original one still getting rejected by verifier
    -   Newer kernel version or newer compiler version can be the underlying cause
    -   Nevertheless, we want to rewrite it, so that it gets verified and the logic is preserved
    -   The dump log shows the rejected instruction at the bytecode level, which may not be evident from the corresponding line of C code
    -   The whole function may need to be understood to debug the rejected lines and rewrite them




# 22-04-22 (scribe: Jinghao)




### Where we are

-   The `libiu` now has basic functionalities.
    -   load maps in the eBPF way
    -   allow userspace to retrieve map fds to communicate with in-kernel programs
-   New onboarding task created
    -   walks through the environment setup and the `hello` example
    -   asks for an inner-unikernel implementation of [trace_event](https://elixir.bootlin.com/linux/v5.15/source/samples/bpf/trace_event_kern.c).
-   New `vmalloc` implementation of loading code finished
    -   Allocates the program as a whole and then sets up page permissions
    -   Not longer need to allocate sections separately, which requires us to
        specify the start and end address for the sections to be on contiguous pages




### Insights & discussion:

-   Current infrastructure does not support multiple programs (entry functions) in
    the same file
    -   This is the case in many eBPF programs, notably kernel samples and BMC
-   Solution to above: make it the eBPF's way
    -   Let user to annotate the entry functions using section attributes
        -   e.g. `SEC("kprobe/__seccomp_filter")` specifies this is an entry function
            for `BPF_PROG_TYPE_KPROBE`.
    -   At load time we first load the whole ELF into the kernel as a base object
        -   Corresponds to one inner-unikernel src file
        -   Could have multiple entry points
    -   Then by using the userspace library to parse out the entry functions, we can
        create actual programs in the kernel that has the `prog->bpf_func` set
        correctly.
        -   These programs should take ref-counts to the base object so that it is not
            deallocated until all programs are gone.
-   Using Rust also allows users to use static variables to store state
    -   States now also stored in programs itselfs, instead of only in maps
    -   Static variables are not atomic. Since programs can be triggered from
        multiple tasks at the same time (e.g. trace-point), accessing them requires
        locks.
-   evaluation: we want to design experiments that makes eBPF look bad and us look
    good
-   security
    -   Side channels and transient execution attack?
    -   Threat model is also interesting, the loading part may be trusted but since
        the actually execution can happen on any task so it's not trusted. Could a
        malicious user trick inner-unikernel programs into doing something bad?




### Where we are going

-   Focus on BMC
    -   eBPF part: @Sayeed42
    -   Rust part + new infrastructure (see above): @jiajinghao1998




# 22-04-15 (scribe: Sayeed)

-   Running `cpustat` might not be possible in VM
    -   The files needed for scaling max frequency is absent in VM
    -   Changing `config` did not work
-   Loading multiple programs succeeded
    -   We should think of following the `libbpf` way to load programs
    -   Current attaching is simpler than `libbpf`
-   Working map implementation similar to the eBPF way
    -   Static struct variables have relocation
    -   No rewriting the address above 32 bits
    -   Difference between map address and program can be more than 32 bits
    -   SOLUTION: Static variable for map and pointer to that variable
-   The eBPF way for maps
    -   Map defined in kernel program and allocated inside the kernel as global
    -   Loading: Iterating through the symbol table to find maps
-   Trust model
    -   Are map offsets in the loader trusted?
    -   Can an attacker pass a bad map offset?
    -   Trusted part in userspace needs to be reduced
    -   Currently the only unsafe portion in Rust is pointer dereferencing
    -   Loader should not be trusted
    -   Think about what normal eBPF loader does which we are not doing (or vice versa)
    -   Signature scheme can be used by Rust compiler
-   Next tasks
    -   Implementing all sample applications to see if we covered all cases
    -   Wrap up loading part -> API can be same as `libbpf`
    -   Trust model like kernel modules
-   Ultimate vision
    -   Running kernel through extensions




# 22-04-01 (scribe: Jinghao)




### Where we are

-   Abstract merged
    -   The second paragraph is expected to be changing over time
-   A working but nasty map implementation
    -   <https://github.com/djwillia/inner_unikernels/blob/main/docs/inner-unitkernel-map.pptx>
    -   problems:
        -   Users needs to agree on the map index they use since a conflict will break
            one of them
        -   The Rust program (kernel) part and the loader (user) part are coupled
            because they now needs to supply the map index
        -   The Rust program does not have the map declarations, which means `rustc`
            cannot type check map accesses.
-   A working `cpustat` sample program




### Insights & discussion:

-   Needs to design a way to support pseudo-distributed applications
-   two crates/libraries
    1.  helper crate: contains all helper implementation and (hopefully) all
        unsafe code
    2.  loader library: provides `libbpf` equivalent APIs
-   Advanced map implementation
    -   Use the same way as current eBPF
        -   generate placeholder reloc in ELF and rewrite the code gradually




### Where we are going

-   start advanced map implementation
-   come up with a list of experiments to do in the paper
    -   the goal is to show the expressiveness and to convinces others
-   Think about the design to support pseudo-distributed applications
-   ask the BMC folks again via email




# 22-03-18 (scribe: Tianyin)

Rough notes:

-   Compatibility issue for managing extension
    -   Only a year, already cannot run the old extension
-   tracex5
-   No need to do tail call
-   No unsafe code in the core; unsafe on the boundary
-   How to manage the code (inner_unikernel create?)
    -   When things get more complex
-   Stub – the address is hardcoded
-   Cannot support array map
-   Diagram of the maps
    -   Compare with the original bpf map
    -   Figure out what each party (Rust app, loader, kernel) is required to do.
-   Get BMC done
-   Write an abstract
-   Cast studies

TODO:

-   Map diagram
    -   Compare with the original bpf map
    -   Figure out what each party (Rust app, loader, kernel) is required to do.
-   CPU stats working without map
-   BMC done
-   Abstract




# 22-03-04 (scribe: Sayeed)

-   Permissions fixed
    -   Can be tested for sanity
-   Map types
    -   Hash, Program arrays, per-cpu etc.
    -   Reason for different types
    -   Generic interface for I/O
    -   Local storage, a bit different from other types
        -   Similar to task storage
-   Map Management
    -   Allocation and deallocation
        -   Userspace: Symbol -> FD
        -   Kernelspace: FD -> Address
    -   Sharing maps across different programs
-   Fuzzing to crash kernel
    -   To find bugs in helper functions that passes the verifier
    -   Fuzzing attachment locations
-   Next Tasks
    -   Implementing simple applications
    -   Implementing BMC
    -   Abstract and evaluation of paper




# 22-02-18 (scribe: Jinghao)

Just realized I forgot to upload the meeting summary




### Where we are

-   finished ELF loader




### Where we are going

-   Doing BPF w/o the verifier
    -   the verifier does checking -> Rust provides type/mem-safety
    -   the verifier rewrites program to use maps -> needs fix
        -   new linking concept: verifier acting as the linker

-   implement map
    -   need a way to link maps and programs (it's done by the verifier in BPF)
        -   current workflow
        -   challenge
        -   potential solutions
    -   reason about the map interface using the applications

-   Two types of applications:
    -   test program: whether the runtime is working
        -   infinite loop
        -   exhaust kernel stack
        -   unsafe Rust code: (arbitrary memory access?)
    -   program that shows the benefit of our framework
        -   BMC
        -   JPG copmressor (stateless)

-   next step:
    -   write test programs
    -   write programs w/ increasing hardness
    -   write a plan




# 22-02-11 (scribe: Sayeed)

-   Implementation progress
    -   Memory management
        -   Done
    -   Page permission
        -   Planned
-   BMC: Whole memcached in BPF?
    -   Application is large
    -   Kernel stack limitations
-   Do we think it can be improved some way if we are not restricted by BPF?
    -   Performance
    -   Better programs
    -   2 programs in Rust versus 7 programs in BPF
-   Tradeoffs between stateless and stateful models
    -   Turing-completeness
    -   Code length limitations
-   Stateful +ves
    -   Better performance
    -   Easy implementation
    -   Existing user programs
    -   Benefits of Rust
        -   Crates (e.g. JPEG Compression, Thumbnail)
-   Stateful -ves
    -   Statefulness -> unpredictability of states
    -   Dependence between functions
    -   Cleaning of states
    -   Process migration
-   Stateless +ves
    -   Extension of serverless
    -   Ability to reuse
-   Stateless -ves
    -   Different states stored in the same place
    -   Organization of states
    -   Stateless granularity
    -   How much state to put into external storage
-   Stateless vs stateful discussion is important, but no need to be solved now
-   SABPF (Audit)
    -   BPF local storage
        -   Task storage




# 22-02-04 (scribe: Jinghao)

Here are the points we discussed today

-   ELF loader
    -   progress: debugging file read function
    -   page permissions: right now it has to be writable to load contents in, need to change to non-writable e.g. for code section
    -   program memory: deallocate pages when ref count gets to 0
-   eBPF maps
    -   life time of maps in eBPF
        1.  created by libbpf
        2.  in-program reference rewritten to fd by libbpf
        3.  fd rewritten to map address by verifier
        4.  deallocated when ref count gets to 0
-   Program model &#x2013; need to think more about how it should look like and in either ways we want type-safety
    -   serverless function/distributed system model (current eBPF)
        -   programs/processes being entirely stateless &#x2013; eBPF is 100% stateless
        -   talking to remote KV storage &#x2013; eBPF maps
    -   uni-kernel model
        -   keeps states in programs
        -   need to find a way to start programs freshly but also with access to the state
    -   more an Dan's notes




# 22-01-28 (scribe: Sayeed)

-   ELF loading (TODO 1)
    -   Proposed to solve the compiler problem with the entry point
    -   Yet to see how Kernel will react
-   Relative positions of the segments
    -   Proposed to be contiguous
    -   Is it really needed to be continuous?
    -   Will there be any problem with page alignment?
-   Permissions
    -   How do you adjust permissions?
-   Is there a better way to allocate the memory?
    -   If two programs are loaded, will there be conflicts?
-   What happens to data segment -> Stack & Heap?
    -   Kernel stack will be used instead of user stack
    -   Current programs don't have heaps
    -   Do we want heaps in BPF or maps are sufficient?
    -   How to integrate the maps?
    -   Map identifiers can be passed to the helper function
    -   Looking at and rewriting verifier (TODO 3)
    -   Performance experiment to measure tradeoffs (TODO 4)
-   Test-driven development
    -   We will gradually run programs of increasing hardness
-   List of BPF programs
    -   Replacing the helper function with expressible Rust
    -   Reduce the number of helper functions
    -   Listing programs, helpers
    -   Classification of helpers based on necessity
    -   1 BPF program to discuss next week - KV store (TODO 2)
-   Priority tasks:
    -   Implementation of ELF loader in the kernel
    -   Discuss KV store (#1) in the next meeting




# 22-01-21 (scribe: Jinghao)

Thanks everyone for attending the meeting, it was an amazing discussion!

We talked about the following:

-   Whether to move the ELF loader into the kernel: our conclusion is yes, as merely putting all the stuff from an ELF file into the kernel might make the data section executable and by moving the loader to the kernel it might save us from running into some nasty problems in the future
-   Attacker & safety:
    -   how shall we go with the threat model and should it be similar to eBPF?
    -   What if an attacker loads some malicious assembly code into our framework? Idea: use a trusted compiler to sign the program (low priority)
    -   safety issue for trusted users: probably adding some additional checks/restrictions &#x2013; depends on later observation (low priority)
-   eBPF map support in Rust:
    -   how to support them in Rust? Maybe perform some rewrite during the loading of ELF in the kernel
-   kernel API and internal headers:
    -   support api headers in Rust: <https://github.com/rust-lang/rust-bindgen> is a good way to go
    -   eBPF programs using internal kernel headers: needs to inspect more eBPF programs

Next Steps:

-   make ELF great again &#x2013; some progress on the in-kernel loader
-   Gather an ordered list of which eBPF program we want to do first or last

