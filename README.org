* Inner Unikernels
The emergence of verified eBPF bytecode is ushering in a new era of safe kernel
extensions. In this paper, we argue that eBPF’s verifier—the source of its
safety guarantees—has become a liability. In addition to the well-known bugs
and vulnerabilities stemming from the complexity and ad hoc nature of the
in-kernel verifier, we highlight a concerning trend in which escape hatches to
unsafe kernel functions (in the form of helper functions) are being introduced
to bypass verifier-imposed limitations on expressiveness, unfortunately also
bypassing its safety guarantees. We propose safe kernel extension frameworks
using a balance of not just static but also lightweight runtime techniques. We
describe a design centered around kernel extensions in safe Rust that will
eliminate the need of the in-kernel verifier, improve expressiveness, allow for
reduced escape hatches, and ultimately improve the safety of kernel extensions.

The basic ideas are documented in [[docs/rust-kernel-ext.pdf][a workshop paper]].

*** Relevant github repos:
- Linux Kernel: [[https://github.com/rosalab/linux/tree/rex-kernel]]
- Rust Toolchain: [[https://github.com/xlab-uiuc/rust]]
- LLVM CodeGen for Rust: [[https://github.com/xlab-uiuc/llvm-rust]]
- Paper Repo: [[https://github.com/rosalab/inner-unikernels-paper]]

Check out the [[docs/minutes.org][meeting minutes]].

[[https://docs.google.com/document/d/1mQyJhhM25mEy63UYRi1JGvph67hJp8Qr8hAR0rJ5YQY/edit#heading=h.yds2twr4pha3][Onboarding task]]
for new students.


* SETUP (version 20230214)
** Nix flake 
Using Nix, a package manager, could allow you to bypass these dependency requirements.

Check out the [[https://nixos.org/download/]] for installation instructions, 
the single-user installation should be enough.

** Dependencies:

The following tools/libraries are required. Older versions are not guaranteed
to (or guaranteed not to) work. This list does not include standard kernel
build dependencies.
- binutils >= 2.38
- elfutils
- pahole
- python tomli package (not needed if python >= 3.11)
- cmake
- ninja
- QEMU

** Repo setup and build

Clone this repo and its submodules:
#+BEGIN_SRC bash
git clone https://github.com/rosalab/rex-kernel.git
cd rex-kernel
git submodule update --init --recursive --progress
#+END_SRC

*** Additional step for Nix
It will launch a Nix shell with all necessary dependencies installed.
All subsequent steps should be carried out within this shell.
#+BEGIN_SRC bash
nix develop --extra-experimental-features nix-command --extra-experimental-features flakes
#+END_SRC

The Linux directory now hosts the kernel repo, checked out at the pre-set
commit. To build the kernel, do:
#+BEGIN_SRC bash
cd linux
cp ../q-script/.config .config
make oldconfig LLVM=1
make -j`nproc` LLVM=1
cd -
#+END_SRC
Note: The default configuration in this repo (~q-script/.config~) uses the LLVM
toolchain (i.e. ~clang~, ~llvm-ar~, ~lld~, etc). If desired, the GNU toolchain
(i.e. ~gcc~, ~ld.bfd~) can be used by removing the ~LLVM=1~ environment
variable setup.

Since ~librex~ loader library depends on the ~libbpf~ shipped with the kernel,
~libbpf~ needs to be built first:
#+BEGIN_SRC bash
cd linux/tools/lib/bpf
make -j`nproc`
cd -
#+END_SRC

Before doing the next step, check if you have gcc 12+ installed:
#+BEGIN_SRC bash
gcc --version
#+END_SRC
If you don't, update gcc.
Alternatively, remove the mold linker by commenting out the line ~use-linker = `mold`~ 
within 
~rex-kernel/rust/inner-unikernels-config.toml~.

Bootstrap Rust:
#+BEGIN_SRC bash
cd rust
./x.py install --config=inner-unikernels-config.toml
cd -
#+END_SRC
The Rust artifacts are installed under ~rust/dist~.

With the linux and Rust setup, add them to the environment:
#+BEGIN_SRC bash
source env.sh
#+END_SRC

Finally build librex:
#+BEGIN_SRC bash
cd librex
make -j`nproc`
cd -
#+END_SRC

** Run ~hello~ example

At this point, you should have ~bindgen~ installed. If not you can install it with:
#+BEGIN_SRC bash
cargo install bindgen-cli
#+END_SRC

If that fails, download binary from source:
#+BEGIN_SRC bash
wget https://github.com/rust-lang/rust-bindgen/releases/download/v0.68.1/bindgen-cli-x86_64-unknown-linux-gnu.tar.xz
tar xf bindgen-cli-x86_64-unknown-linux-gnu.tar.xz
#+END_SRC
Then copy ~bindgen-cli-x86_64-unknown-linux-gnu/bindgen~ to ~​~/bin/~.

First build the source
#+BEGIN_SRC bash
cd samples/hello
make
cd -
#+END_SRC

If Clang throws an error while ~make~ ing, simply update it or alternately, download binary:
#+BEGIN_SRC bash
wget https://github.com/llvm/llvm-project/releases/download/llvmorg-17.0.6/clang+llvm-17.0.6-x86_64-linux-gnu-ubuntu-22.04.tar.xz
tar xf clang+llvm-17.0.6-x86_64-linux-gnu-ubuntu-22.04.tar.xz
#+END_SRC
Then add 
~export PATH=`/path/to/clang+llvm-17.0.6-x86_64-linux-gnu-ubuntu-22.04/bin:$PATH`~ 
at the end of 
~​~/.profile~

Then boot the VM:
#+BEGIN_SRC bash
cd linux
../q-script/yifei-q # use ../q-script/nix-q instead if you are using Nix
#+END_SRC

To run the VM, you may also need to add your user to the ~KVM~ group, using:
#+BEGIN_SRC bash
sudo usermod -a -G groupName userName
#+END_SRC
If that fails, contact your administrator.

Inside the VM:
#+BEGIN_SRC bash
cd ..
export LD_LIBRARY_PATH=`realpath ./librex`:`realpath linux/tools/lib/bpf`:$LD_LIBRARY_PATH
cd samples/hello
./loader & 
./event_trigger
#+END_SRC

The following output should be printed out:
#+BEGIN_EXAMPLE
<...>-245     [002] d...1    18.417331: bpf_trace_printk: Rust triggered from PID 245.
#+END_EXAMPLE

* Docker Setup

In this setup, we will have ~runtime~ docker as the all-in-one environment for compiling and running the samples.

** Host Requirements

- Docker
- Qemu

** Repo setup 

Clone this repo and its submodules:
#+BEGIN_SRC bash
git clone --recursive https://github.com/rosalab/rex-kernel.git
cd rex-kernel
#+END_SRC

** Build Docker

#+BEGIN_SRC bash
# build by docker builder (it takes a lot of time)
make docker
#+END_SRC

** Build Dependencies

#+BEGIN_SRC bash
# On host
cp ./q-script/.config ./linux/.config
# rebuild kernel
make kernel
# build headers_install
make headers-install
# build kernel
make vmlinux
# build bpf
make bpftool
# build librex
make iu
#+END_SRC

** Run Sample Hello

#+BEGIN_SRC bash
# build sample hello
make iu-examples
# start qemu
make qemu-run
# start ssh session with qemu
make qemu-ssh 
# assign ssh port with SSH_PORT env 
SSH_PORT=52222 make qemu-run
SSH_PORT=52222 make qemu-ssh
# alternatively, use standard ssh to connect to vm
ssh -o "UserKnownHostsFile=/dev/null" -o "StrictHostKeyChecking=no" -t root@127.0.0.1 -p 52222
# run sample hello
cd ../samples/hello
./loader &
./event-trigger
#+END_SRC

** Run with gdb
#+BEGIN_SRC bash
# prepare with remote gdb (default port is 1234)
gdb linux/vmlinux -ex "target remote localhost:1234"
# start qemu with gdb port mapping
make qemu-run-gdb 

# The boot process will halt and the below output is expected. 
Reading symbols from linux/vmlinux...
Remote debugging using localhost:1234
0x00000000000ea0b6 in ?? ()
# Type `c` to continue
(gdb) c
Continuing.
#+END_SRC

*** Docker FAQ

- Q: What can I do if I encounter network error when doing the apt update?
- A: In the ~./docker/docker-linux-builder/Makefile~, add ~--network=host~ in the docker command. ~docker build --progress=plain --network=host -t runtime~.

** Migration to ROSA lab

If you haven't update your remote url, you need to update it:
#+BEGIN_SRC bash
# Assuming the remote is called "origin"
git remote set-url origin git@github.com:rosalab/rex-kernel.git
#+END_SRC

To update the Linux submodule link in case you are not on `main`, you need to
backport commit [[https://github.com/rosalab/rex-kernel/commit/69680052549ba993049c05bcb6e3573b3bc23dc3.patch][69680052549b]]

No matter you are on `main` or not, you need to sync submodules again:
#+BEGIN_SRC bash
git submodule sync
#+END_SRC
