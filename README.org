* Rex (Rex eBPF eXtension)
The emergence of verified eBPF bytecode is ushering in a new era of safe
kernel extensions. In this paper, we argue that eBPF’s verifier—the source
of its safety guarantees—has become a liability. In addition to the
well-known bugs and vulnerabilities stemming from the complexity and ad hoc
nature of the in-kernel verifier, we highlight a concerning trend in which
escape hatches to unsafe kernel functions (in the form of helper functions)
are being introduced to bypass verifier-imposed limitations on
expressiveness, unfortunately also bypassing its safety guarantees. We
propose safe kernel extension frameworks using a balance of not just static
but also lightweight runtime techniques. We describe a design centered
around kernel extensions in safe Rust that will eliminate the need of the
in-kernel verifier, improve expressiveness, allow for reduced escape
hatches, and ultimately improve the safety of kernel extensions.

The basic ideas are documented in [[docs/rust-kernel-ext.pdf][a workshop
paper]].

*** Relevant github repos:
- Linux Kernel: [[https://github.com/rosalab/linux/tree/rex-kernel]]
- Rust Toolchain: [[https://github.com/xlab-uiuc/rust]]
- LLVM CodeGen for Rust: [[https://github.com/xlab-uiuc/llvm-rust]]
- Paper Repo: [[https://github.com/rosalab/inner-unikernels-paper]]

Check out the [[docs/minutes.org][meeting minutes]].

[[https://docs.google.com/document/d/1mQyJhhM25mEy63UYRi1JGvph67hJp8Qr8hAR0rJ5YQY/edit#heading=h.yds2twr4pha3][Onboarding task]]
for new students.


* SETUP (version 20240720)
** Nix flake 
Using Nix, a package manager, could allow you to bypass these dependency
requirements below.

Check out the [[https://nixos.org/download/]] for installation
instructions, the single-user installation should be enough.

** Dependencies:

The following tools/libraries are required. Older versions are not
guaranteed to (or guaranteed not to) work. This list does not include
standard kernel build dependencies.
- binutils (>= 2.38)
- cmake
- elfutils
- mold linker
- ninja
- pahole
- python (>= 3.11)
- QEMU

** Repo setup and build

Clone this repo and its submodules:
#+BEGIN_SRC bash
git clone https://github.com/rosalab/rex-kernel.git
cd rex-kernel
git submodule update --init --recursive --progress
#+END_SRC

*** Additional step for Nix
It will launch a Nix shell with all necessary dependencies installed.
All subsequent steps should be carried out within this shell.
#+BEGIN_SRC bash
nix develop --extra-experimental-features nix-command --extra-experimental-features flakes
#+END_SRC

The Linux directory now hosts the kernel repo, checked out at the pre-set
commit. To build the kernel, do:
#+BEGIN_SRC bash
cd linux
cp ../scripts/q-script/.config .config
make oldconfig LLVM=1
make -j`nproc` LLVM=1
cd -
#+END_SRC
Note: The default configuration in this repo (~q-script/.config~) uses the
LLVM toolchain (i.e. ~clang~, ~llvm-ar~, ~lld~, etc). If desired, the GNU
toolchain (i.e. ~gcc~, ~ld.bfd~) can be used by removing the ~LLVM=1~
environment variable setup.

Since ~librex~ loader library depends on the ~libbpf~ shipped with the
kernel, ~libbpf~ needs to be built first:
#+BEGIN_SRC bash
cd linux/tools/lib/bpf
make -j`nproc`
cd -
#+END_SRC

Before moving to the next step, check if you have gcc 12+ installed:
#+BEGIN_SRC bash
gcc --version
#+END_SRC
If you don't, you need to update gcc.

Rex uses custom LLVM passes in the Rust compiler to generate additional
code and instruments the extension programs, therefore,
[[https://en.wikipedia.org/wiki/Bootstrapping_(compilers)][bootstraping]]
the Rust compiler is required:
#+BEGIN_SRC bash
cd rust
./x.py install --config=rex-config.toml
cd -
#+END_SRC
This will bootstrap a Rust compiler and build the relevant tools (e.g.,
~cargo~, ~rust-demangler~, etc).  The Rust artifacts will be installed
under ~rust/dist~.

With the linux and Rust setup, add them to the environment (skip if using
Nix):
#+BEGIN_SRC bash
source ./scripts/env.sh
#+END_SRC

Finally build librex:
#+BEGIN_SRC bash
cd librex
make -j`nproc`
cd -
#+END_SRC

** Run ~hello~ example

At this point, you should have ~bindgen~ installed. If not you can install
it with:
#+BEGIN_SRC bash
cargo install bindgen-cli
#+END_SRC

If that fails, download binary from source:
#+BEGIN_SRC bash
wget https://github.com/rust-lang/rust-bindgen/releases/download/v0.68.1/bindgen-cli-x86_64-unknown-linux-gnu.tar.xz
tar xf bindgen-cli-x86_64-unknown-linux-gnu.tar.xz
#+END_SRC
Then copy ~bindgen-cli-x86_64-unknown-linux-gnu/bindgen~ to ~​~/bin/~.

First build the source
#+BEGIN_SRC bash
cd samples/hello
make
cd -
#+END_SRC

If Clang throws an error while ~make~ing, simply update it or alternately,
download binary:
#+BEGIN_SRC bash
wget https://github.com/llvm/llvm-project/releases/download/llvmorg-17.0.6/clang+llvm-17.0.6-x86_64-linux-gnu-ubuntu-22.04.tar.xz
tar xf clang+llvm-17.0.6-x86_64-linux-gnu-ubuntu-22.04.tar.xz
#+END_SRC
Then add 
~export PATH=`/path/to/clang+llvm-17.0.6-x86_64-linux-gnu-ubuntu-22.04/bin:$PATH`~ 
at the end of 
~​~/.profile~

Then boot the VM:
#+BEGIN_SRC bash
cd linux
../scripts/q-script/yifei-q # use ../scripts/q-script/nix-q instead if you are using Nix
#+END_SRC

To run the VM, you may also need to add your user to the ~KVM~ group to
avoid using sudo everytime:
#+BEGIN_SRC bash
sudo usermod -a -G groupName userName
#+END_SRC
If that fails, contact your administrator.

Inside the VM:
#+BEGIN_SRC bash
cd ..
cd samples/hello
./loader & 
./event_trigger
#+END_SRC

The following output should be printed out:
#+BEGIN_EXAMPLE
<...>-245     [002] d...1    18.417331: bpf_trace_printk: Rust triggered from PID 245.
#+END_EXAMPLE

** Debugging kernrel problems with gdb
#+BEGIN_SRC bash
# prepare with remote gdb (default port is 1234)
gdb linux/vmlinux -ex "target remote localhost:1234"
# start qemu with gdb port mapping
make qemu-run-gdb 

# The boot process will halt and the below output is expected. 
Reading symbols from linux/vmlinux...
Remote debugging using localhost:1234
0x00000000000ea0b6 in ?? ()
# Type `c` to continue
(gdb) c
Continuing.
#+END_SRC

