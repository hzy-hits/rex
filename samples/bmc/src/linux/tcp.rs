/* automatically generated by rust-bindgen 0.59.2 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const __BITS_PER_LONG: u32 = 64;
pub const __FD_SETSIZE: u32 = 1024;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const _K_SS_MAXSIZE: u32 = 128;
pub const SOCK_SNDBUF_LOCK: u32 = 1;
pub const SOCK_RCVBUF_LOCK: u32 = 2;
pub const SOCK_BUF_LOCK_MASK: u32 = 3;
pub const TCP_MSS_DEFAULT: u32 = 536;
pub const TCP_MSS_DESIRED: u32 = 1220;
pub const TCP_NODELAY: u32 = 1;
pub const TCP_MAXSEG: u32 = 2;
pub const TCP_CORK: u32 = 3;
pub const TCP_KEEPIDLE: u32 = 4;
pub const TCP_KEEPINTVL: u32 = 5;
pub const TCP_KEEPCNT: u32 = 6;
pub const TCP_SYNCNT: u32 = 7;
pub const TCP_LINGER2: u32 = 8;
pub const TCP_DEFER_ACCEPT: u32 = 9;
pub const TCP_WINDOW_CLAMP: u32 = 10;
pub const TCP_INFO: u32 = 11;
pub const TCP_QUICKACK: u32 = 12;
pub const TCP_CONGESTION: u32 = 13;
pub const TCP_MD5SIG: u32 = 14;
pub const TCP_THIN_LINEAR_TIMEOUTS: u32 = 16;
pub const TCP_THIN_DUPACK: u32 = 17;
pub const TCP_USER_TIMEOUT: u32 = 18;
pub const TCP_REPAIR: u32 = 19;
pub const TCP_REPAIR_QUEUE: u32 = 20;
pub const TCP_QUEUE_SEQ: u32 = 21;
pub const TCP_REPAIR_OPTIONS: u32 = 22;
pub const TCP_FASTOPEN: u32 = 23;
pub const TCP_TIMESTAMP: u32 = 24;
pub const TCP_NOTSENT_LOWAT: u32 = 25;
pub const TCP_CC_INFO: u32 = 26;
pub const TCP_SAVE_SYN: u32 = 27;
pub const TCP_SAVED_SYN: u32 = 28;
pub const TCP_REPAIR_WINDOW: u32 = 29;
pub const TCP_FASTOPEN_CONNECT: u32 = 30;
pub const TCP_ULP: u32 = 31;
pub const TCP_MD5SIG_EXT: u32 = 32;
pub const TCP_FASTOPEN_KEY: u32 = 33;
pub const TCP_FASTOPEN_NO_COOKIE: u32 = 34;
pub const TCP_ZEROCOPY_RECEIVE: u32 = 35;
pub const TCP_INQ: u32 = 36;
pub const TCP_CM_INQ: u32 = 36;
pub const TCP_TX_DELAY: u32 = 37;
pub const TCP_REPAIR_ON: u32 = 1;
pub const TCP_REPAIR_OFF: u32 = 0;
pub const TCP_REPAIR_OFF_NO_WP: i32 = -1;
pub const TCPI_OPT_TIMESTAMPS: u32 = 1;
pub const TCPI_OPT_SACK: u32 = 2;
pub const TCPI_OPT_WSCALE: u32 = 4;
pub const TCPI_OPT_ECN: u32 = 8;
pub const TCPI_OPT_ECN_SEEN: u32 = 16;
pub const TCPI_OPT_SYN_DATA: u32 = 32;
pub const TCP_MD5SIG_MAXKEYLEN: u32 = 80;
pub const TCP_MD5SIG_FLAG_PREFIX: u32 = 1;
pub const TCP_MD5SIG_FLAG_IFINDEX: u32 = 2;
pub const TCP_RECEIVE_ZEROCOPY_FLAG_TLB_CLEAN_HINT: u32 = 1;
pub type __s8 = i8;
pub type __u8 = u8;
pub type __s16 = i16;
pub type __u16 = u16;
pub type __s32 = i32;
pub type __u32 = u32;
pub type __s64 = i64;
pub type __u64 = u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fd_set {
    pub fds_bits: [u64; 16usize],
}
pub type __kernel_sighandler_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: i32)>;
pub type __kernel_key_t = i32;
pub type __kernel_mqd_t = i32;
pub type __kernel_old_uid_t = u16;
pub type __kernel_old_gid_t = u16;
pub type __kernel_old_dev_t = u64;
pub type __kernel_long_t = i64;
pub type __kernel_ulong_t = u64;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = u32;
pub type __kernel_pid_t = i32;
pub type __kernel_ipc_pid_t = i32;
pub type __kernel_uid_t = u32;
pub type __kernel_gid_t = u32;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = i32;
pub type __kernel_uid32_t = u32;
pub type __kernel_gid32_t = u32;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_ptrdiff_t = __kernel_long_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fsid_t {
    pub val: [i32; 2usize],
}
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = i64;
pub type __kernel_old_time_t = __kernel_long_t;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_time64_t = i64;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = i32;
pub type __kernel_clockid_t = i32;
pub type __kernel_caddr_t = *mut i8;
pub type __kernel_uid16_t = u16;
pub type __kernel_gid16_t = u16;
pub type __le16 = __u16;
pub type __be16 = __u16;
pub type __le32 = __u32;
pub type __be32 = __u32;
pub type __le64 = __u64;
pub type __be64 = __u64;
pub type __sum16 = __u16;
pub type __wsum = __u32;
pub type __poll_t = u32;
pub type __kernel_sa_family_t = u16;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __kernel_sockaddr_storage {
    pub __bindgen_anon_1: __kernel_sockaddr_storage__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __kernel_sockaddr_storage__bindgen_ty_1 {
    pub __bindgen_anon_1: __kernel_sockaddr_storage__bindgen_ty_1__bindgen_ty_1,
    pub __align: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_sockaddr_storage__bindgen_ty_1__bindgen_ty_1 {
    pub ss_family: __kernel_sa_family_t,
    pub __data: [i8; 126usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcphdr {
    pub source: __be16,
    pub dest: __be16,
    pub seq: __be32,
    pub ack_seq: __be32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub window: __be16,
    pub check: __sum16,
    pub urg_ptr: __be16,
}
impl tcphdr {
    #[inline]
    pub fn res1(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_res1(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn doff(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_doff(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn fin(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_fin(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn syn(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_syn(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rst(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_rst(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn psh(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_psh(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ack(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ack(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn urg(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_urg(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ece(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ece(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cwr(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_cwr(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        res1: __u16,
        doff: __u16,
        fin: __u16,
        syn: __u16,
        rst: __u16,
        psh: __u16,
        ack: __u16,
        urg: __u16,
        ece: __u16,
        cwr: __u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let res1: u16 = unsafe { ::core::mem::transmute(res1) };
            res1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let doff: u16 = unsafe { ::core::mem::transmute(doff) };
            doff as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let fin: u16 = unsafe { ::core::mem::transmute(fin) };
            fin as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let syn: u16 = unsafe { ::core::mem::transmute(syn) };
            syn as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let rst: u16 = unsafe { ::core::mem::transmute(rst) };
            rst as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let psh: u16 = unsafe { ::core::mem::transmute(psh) };
            psh as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let ack: u16 = unsafe { ::core::mem::transmute(ack) };
            ack as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let urg: u16 = unsafe { ::core::mem::transmute(urg) };
            urg as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let ece: u16 = unsafe { ::core::mem::transmute(ece) };
            ece as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let cwr: u16 = unsafe { ::core::mem::transmute(cwr) };
            cwr as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tcp_word_hdr {
    pub hdr: tcphdr,
    pub words: [__be32; 5usize],
}
pub const TCP_FLAG_CWR: u32 = 32768;
pub const TCP_FLAG_ECE: u32 = 16384;
pub const TCP_FLAG_URG: u32 = 8192;
pub const TCP_FLAG_ACK: u32 = 4096;
pub const TCP_FLAG_PSH: u32 = 2048;
pub const TCP_FLAG_RST: u32 = 1024;
pub const TCP_FLAG_SYN: u32 = 512;
pub const TCP_FLAG_FIN: u32 = 256;
pub const TCP_RESERVED_BITS: u32 = 15;
pub const TCP_DATA_OFFSET: u32 = 240;
pub type _bindgen_ty_1 = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_repair_opt {
    pub opt_code: __u32,
    pub opt_val: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_repair_window {
    pub snd_wl1: __u32,
    pub snd_wnd: __u32,
    pub max_window: __u32,
    pub rcv_wnd: __u32,
    pub rcv_wup: __u32,
}
pub const TCP_NO_QUEUE: u32 = 0;
pub const TCP_RECV_QUEUE: u32 = 1;
pub const TCP_SEND_QUEUE: u32 = 2;
pub const TCP_QUEUES_NR: u32 = 3;
pub type _bindgen_ty_2 = u32;
pub const tcp_fastopen_client_fail_TFO_STATUS_UNSPEC: tcp_fastopen_client_fail = 0;
pub const tcp_fastopen_client_fail_TFO_COOKIE_UNAVAILABLE: tcp_fastopen_client_fail = 1;
pub const tcp_fastopen_client_fail_TFO_DATA_NOT_ACKED: tcp_fastopen_client_fail = 2;
pub const tcp_fastopen_client_fail_TFO_SYN_RETRANSMITTED: tcp_fastopen_client_fail = 3;
pub type tcp_fastopen_client_fail = u32;
pub const tcp_ca_state_TCP_CA_Open: tcp_ca_state = 0;
pub const tcp_ca_state_TCP_CA_Disorder: tcp_ca_state = 1;
pub const tcp_ca_state_TCP_CA_CWR: tcp_ca_state = 2;
pub const tcp_ca_state_TCP_CA_Recovery: tcp_ca_state = 3;
pub const tcp_ca_state_TCP_CA_Loss: tcp_ca_state = 4;
pub type tcp_ca_state = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_info {
    pub tcpi_state: __u8,
    pub tcpi_ca_state: __u8,
    pub tcpi_retransmits: __u8,
    pub tcpi_probes: __u8,
    pub tcpi_backoff: __u8,
    pub tcpi_options: __u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub tcpi_rto: __u32,
    pub tcpi_ato: __u32,
    pub tcpi_snd_mss: __u32,
    pub tcpi_rcv_mss: __u32,
    pub tcpi_unacked: __u32,
    pub tcpi_sacked: __u32,
    pub tcpi_lost: __u32,
    pub tcpi_retrans: __u32,
    pub tcpi_fackets: __u32,
    pub tcpi_last_data_sent: __u32,
    pub tcpi_last_ack_sent: __u32,
    pub tcpi_last_data_recv: __u32,
    pub tcpi_last_ack_recv: __u32,
    pub tcpi_pmtu: __u32,
    pub tcpi_rcv_ssthresh: __u32,
    pub tcpi_rtt: __u32,
    pub tcpi_rttvar: __u32,
    pub tcpi_snd_ssthresh: __u32,
    pub tcpi_snd_cwnd: __u32,
    pub tcpi_advmss: __u32,
    pub tcpi_reordering: __u32,
    pub tcpi_rcv_rtt: __u32,
    pub tcpi_rcv_space: __u32,
    pub tcpi_total_retrans: __u32,
    pub tcpi_pacing_rate: __u64,
    pub tcpi_max_pacing_rate: __u64,
    pub tcpi_bytes_acked: __u64,
    pub tcpi_bytes_received: __u64,
    pub tcpi_segs_out: __u32,
    pub tcpi_segs_in: __u32,
    pub tcpi_notsent_bytes: __u32,
    pub tcpi_min_rtt: __u32,
    pub tcpi_data_segs_in: __u32,
    pub tcpi_data_segs_out: __u32,
    pub tcpi_delivery_rate: __u64,
    pub tcpi_busy_time: __u64,
    pub tcpi_rwnd_limited: __u64,
    pub tcpi_sndbuf_limited: __u64,
    pub tcpi_delivered: __u32,
    pub tcpi_delivered_ce: __u32,
    pub tcpi_bytes_sent: __u64,
    pub tcpi_bytes_retrans: __u64,
    pub tcpi_dsack_dups: __u32,
    pub tcpi_reord_seen: __u32,
    pub tcpi_rcv_ooopack: __u32,
    pub tcpi_snd_wnd: __u32,
}
impl tcp_info {
    #[inline]
    pub fn tcpi_snd_wscale(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_tcpi_snd_wscale(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn tcpi_rcv_wscale(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_tcpi_rcv_wscale(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn tcpi_delivery_rate_app_limited(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tcpi_delivery_rate_app_limited(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tcpi_fastopen_client_fail(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_tcpi_fastopen_client_fail(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tcpi_snd_wscale: __u8,
        tcpi_rcv_wscale: __u8,
        tcpi_delivery_rate_app_limited: __u8,
        tcpi_fastopen_client_fail: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let tcpi_snd_wscale: u8 = unsafe { ::core::mem::transmute(tcpi_snd_wscale) };
            tcpi_snd_wscale as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let tcpi_rcv_wscale: u8 = unsafe { ::core::mem::transmute(tcpi_rcv_wscale) };
            tcpi_rcv_wscale as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let tcpi_delivery_rate_app_limited: u8 =
                unsafe { ::core::mem::transmute(tcpi_delivery_rate_app_limited) };
            tcpi_delivery_rate_app_limited as u64
        });
        __bindgen_bitfield_unit.set(9usize, 2u8, {
            let tcpi_fastopen_client_fail: u8 =
                unsafe { ::core::mem::transmute(tcpi_fastopen_client_fail) };
            tcpi_fastopen_client_fail as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const TCP_NLA_PAD: u32 = 0;
pub const TCP_NLA_BUSY: u32 = 1;
pub const TCP_NLA_RWND_LIMITED: u32 = 2;
pub const TCP_NLA_SNDBUF_LIMITED: u32 = 3;
pub const TCP_NLA_DATA_SEGS_OUT: u32 = 4;
pub const TCP_NLA_TOTAL_RETRANS: u32 = 5;
pub const TCP_NLA_PACING_RATE: u32 = 6;
pub const TCP_NLA_DELIVERY_RATE: u32 = 7;
pub const TCP_NLA_SND_CWND: u32 = 8;
pub const TCP_NLA_REORDERING: u32 = 9;
pub const TCP_NLA_MIN_RTT: u32 = 10;
pub const TCP_NLA_RECUR_RETRANS: u32 = 11;
pub const TCP_NLA_DELIVERY_RATE_APP_LMT: u32 = 12;
pub const TCP_NLA_SNDQ_SIZE: u32 = 13;
pub const TCP_NLA_CA_STATE: u32 = 14;
pub const TCP_NLA_SND_SSTHRESH: u32 = 15;
pub const TCP_NLA_DELIVERED: u32 = 16;
pub const TCP_NLA_DELIVERED_CE: u32 = 17;
pub const TCP_NLA_BYTES_SENT: u32 = 18;
pub const TCP_NLA_BYTES_RETRANS: u32 = 19;
pub const TCP_NLA_DSACK_DUPS: u32 = 20;
pub const TCP_NLA_REORD_SEEN: u32 = 21;
pub const TCP_NLA_SRTT: u32 = 22;
pub const TCP_NLA_TIMEOUT_REHASH: u32 = 23;
pub const TCP_NLA_BYTES_NOTSENT: u32 = 24;
pub const TCP_NLA_EDT: u32 = 25;
pub const TCP_NLA_TTL: u32 = 26;
pub type _bindgen_ty_3 = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tcp_md5sig {
    pub tcpm_addr: __kernel_sockaddr_storage,
    pub tcpm_flags: __u8,
    pub tcpm_prefixlen: __u8,
    pub tcpm_keylen: __u16,
    pub tcpm_ifindex: i32,
    pub tcpm_key: [__u8; 80usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_diag_md5sig {
    pub tcpm_family: __u8,
    pub tcpm_prefixlen: __u8,
    pub tcpm_keylen: __u16,
    pub tcpm_addr: [__be32; 4usize],
    pub tcpm_key: [__u8; 80usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_zerocopy_receive {
    pub address: __u64,
    pub length: __u32,
    pub recv_skip_hint: __u32,
    pub inq: __u32,
    pub err: __s32,
    pub copybuf_address: __u64,
    pub copybuf_len: __s32,
    pub flags: __u32,
    pub msg_control: __u64,
    pub msg_controllen: __u64,
    pub msg_flags: __u32,
    pub reserved: __u32,
}
