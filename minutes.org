MEETING MINUTES
* 22-04-22 (scribe: Jinghao)
*** Where we are
- The ~libiu~ now has basic functionalities.
  - load maps in the eBPF way
  - allow userspace to retrieve map fds to communicate with in-kernel programs
- New onboarding task created
  - walks through the environment setup and the ~hello~ example
  - asks for an inner-unikernel implementation of [[https://elixir.bootlin.com/linux/v5.15/source/samples/bpf/trace_event_kern.c][trace_event]].

*** Insights & discussion:
- Current infrastructure does not support multiple programs (entry functions) in
  the same file
  - This is the case in many eBPF programs, notably kernel samples and BMC
- Solution to above: make it the eBPF's way
  - Let user to annotate the entry functions using section attributes
    - e.g. ~SEC("kprobe/__seccomp_filter")~ specifies this is an entry function
      for ~BPF_PROG_TYPE_KPROBE~.
  - At load time we first load the whole ELF into the kernel as a base object
    - Corresponds to one inner-unikernel src file
    - Could have multiple entry points
  - Then by using the userspace library to parse out the entry functions, we can
    create actual programs in the kernel that has the ~prog->bpf_func~ set
    correctly.
    - These programs should take ref-counts to the base object so that it is not
      deallocated until all programs are gone.
- Using Rust also allows users to use static variables to store state
  - States now also stored in programs itselfs, instead of only in maps
  - Static variables are not atomic. Since programs can be triggered from
    multiple tasks at the same time (e.g. trace-point), accessing them requires
    locks.
- evaluation: we want to design experiments that makes eBPF look bad and us look
  good
- security
  - Side channels and transient execution attack?
  - Threat model is also interesting, the loading part may be trusted but since
    the actually execution can happen on any task so it's not trusted. Could a
    malicious user trick inner-unikernel programs into doing something bad?

*** Where we are going
- Focus on BMC
  - eBPF part: @Sayeed42
  - Rust part + new infrastructure (see above): @jiajinghao1998

* 22-04-15 (scribe: Sayeed)
- Running ~cpustat~ might not be possible in VM
  - The files needed for scaling max frequency is absent in VM
  - Changing ~config~ did not work
- Loading multiple programs succeeded
  - We should think of following the ~libbpf~ way to load programs
  - Current attaching is simpler than ~libbpf~
- Working map implementation similar to the eBPF way
  - Static struct variables have relocation
  - No rewriting the address above 32 bits
  - Difference between map address and program can be more than 32 bits
  - SOLUTION: Static variable for map and pointer to that variable
- The eBPF way for maps
  - Map defined in kernel program and allocated inside the kernel as global
  - Loading: Iterating through the symbol table to find maps
- Trust model
  - Are map offsets in the loader trusted?
  - Can an attacker pass a bad map offset?
  - Trusted part in userspace needs to be reduced
  - Currently the only unsafe portion in Rust is pointer dereferencing
  - Loader should not be trusted
  - Think about what normal eBPF loader does which we are not doing (or vice versa)
  - Signature scheme can be used by Rust compiler
- Next tasks
  - Implementing all sample applications to see if we covered all cases
  - Wrap up loading part -> API can be same as ~libbpf~
  - Trust model like kernel modules
- Ultimate vision
  - Running kernel through extensions
* 22-04-01 (scribe: Jinghao)
*** Where we are
- Abstract merged
  - The second paragraph is expected to be changing over time
- A working but nasty map implementation
  - https://github.com/djwillia/inner_unikernels/blob/main/docs/inner-unitkernel-map.pptx
  - problems:
    - Users needs to agree on the map index they use since a conflict will break
      one of them
    - The Rust program (kernel) part and the loader (user) part are coupled
      because they now needs to supply the map index
    - The Rust program does not have the map declarations, which means ~rustc~
      cannot type check map accesses.
- A working ~cpustat~ sample program

*** Insights & discussion:
  - Needs to design a way to support pseudo-distributed applications
  - two crates/libraries
    1. helper crate: contains all helper implementation and (hopefully) all
       unsafe code
    2. loader library: provides ~libbpf~ equivalent APIs
  - Advanced map implementation
    - Use the same way as current eBPF
      - generate placeholder reloc in ELF and rewrite the code gradually

*** Where we are going
  - start advanced map implementation
  - come up with a list of experiments to do in the paper
    - the goal is to show the expressiveness and to convinces others
  - Think about the design to support pseudo-distributed applications
  - ask the BMC folks again via email

* 22-03-18 (scribe: Tianyin)
Rough notes:
- Compatibility issue for managing extension
  - Only a year, already cannot run the old extension
- tracex5
- No need to do tail call
- No unsafe code in the core; unsafe on the boundary
- How to manage the code (inner_unikernel create?)
  - When things get more complex
- Stub â€“ the address is hardcoded
- Cannot support array map
- Diagram of the maps
  - Compare with the original bpf map
  - Figure out what each party (Rust app, loader, kernel) is required to do.
- Get BMC done
- Write an abstract
- Cast studies

TODO:
- Map diagram
  - Compare with the original bpf map
  - Figure out what each party (Rust app, loader, kernel) is required to do.
- CPU stats working without map
- BMC done
- Abstract

* 22-03-04 (scribe: Sayeed)
- Permissions fixed
	- Can be tested for sanity
- Map types
	- Hash, Program arrays, per-cpu etc.
	- Reason for different types
	- Generic interface for I/O
	- Local storage, a bit different from other types
		- Similar to task storage
- Map Management
	- Allocation and deallocation
		- Userspace: Symbol -> FD
		- Kernelspace: FD -> Address
	- Sharing maps across different programs
- Fuzzing to crash kernel
	- To find bugs in helper functions that passes the verifier
	- Fuzzing attachment locations
- Next Tasks
	- Implementing simple applications
	- Implementing BMC
	- Abstract and evaluation of paper

* 22-02-18 (scribe: Jinghao)
Just realized I forgot to upload the meeting summary

*** Where we are
- finished ELF loader

*** Where we are going
- Doing BPF w/o the verifier
    - the verifier does checking -> Rust provides type/mem-safety
    - the verifier rewrites program to use maps -> needs fix
        - new linking concept: verifier acting as the linker

- implement map
    - need a way to link maps and programs (it's done by the verifier in BPF)
        - current workflow
        - challenge
        - potential solutions
    - reason about the map interface using the applications

- Two types of applications:
    - test program: whether the runtime is working
        - infinite loop
        - exhaust kernel stack
        - unsafe Rust code: (arbitrary memory access?)
    - program that shows the benefit of our framework
        - BMC
        - JPG copmressor (stateless)

- next step:
    - write test programs
    - write programs w/ increasing hardness
    - write a plan

* 22-02-11 (scribe: Sayeed)
- Implementation progress
	- Memory management
		- Done
	- Page permission
		- Planned
- BMC: Whole memcached in BPF?
	- Application is large
	- Kernel stack limitations
- Do we think it can be improved some way if we are not restricted by BPF?
	- Performance
	- Better programs
	- 2 programs in Rust versus 7 programs in BPF
- Tradeoffs between stateless and stateful models
	- Turing-completeness
	- Code length limitations
- Stateful +ves
	- Better performance
	- Easy implementation
	- Existing user programs
	- Benefits of Rust
		- Crates (e.g. JPEG Compression, Thumbnail)
- Stateful -ves
	- Statefulness -> unpredictability of states
	- Dependence between functions
	- Cleaning of states
	- Process migration
- Stateless +ves
	- Extension of serverless
	- Ability to reuse
- Stateless -ves
	- Different states stored in the same place
	- Organization of states
	- Stateless granularity
	- How much state to put into external storage
- Stateless vs stateful discussion is important, but no need to be solved now
- SABPF (Audit)
	- BPF local storage
		- Task storage

* 22-02-04 (scribe: Jinghao)
Here are the points we discussed today

- ELF loader
    - progress: debugging file read function
    - page permissions: right now it has to be writable to load contents in, need to change to non-writable e.g. for code section
    - program memory: deallocate pages when ref count gets to 0
- eBPF maps
    - life time of maps in eBPF
        1.  created by libbpf
        2. in-program reference rewritten to fd by libbpf
        3. fd rewritten to map address by verifier
        4. deallocated when ref count gets to 0
- Program model -- need to think more about how it should look like and in either ways we want type-safety
    - serverless function/distributed system model (current eBPF)
        - programs/processes being entirely stateless -- eBPF is 100% stateless
        - talking to remote KV storage -- eBPF maps
    - uni-kernel model
        - keeps states in programs
        - need to find a way to start programs freshly but also with access to the state
    - more an Dan's notes

* 22-01-28 (scribe: Sayeed)
- ELF loading (TODO 1)
	- Proposed to solve the compiler problem with the entry point
	- Yet to see how Kernel will react
- Relative positions of the segments
	- Proposed to be contiguous
	- Is it really needed to be continuous?
	- Will there be any problem with page alignment?
- Permissions
	- How do you adjust permissions?
- Is there a better way to allocate the memory?
	- If two programs are loaded, will there be conflicts?
- What happens to data segment -> Stack & Heap?
	- Kernel stack will be used instead of user stack
	- Current programs don't have heaps
	- Do we want heaps in BPF or maps are sufficient?
	- How to integrate the maps?
	- Map identifiers can be passed to the helper function
	- Looking at and rewriting verifier (TODO 3)
	- Performance experiment to measure tradeoffs (TODO 4)
- Test-driven development
	- We will gradually run programs of increasing hardness
- List of BPF programs
	- Replacing the helper function with expressible Rust
	- Reduce the number of helper functions
	- Listing programs, helpers
	- Classification of helpers based on necessity
	- 1 BPF program to discuss next week - KV store (TODO 2)
-  Priority tasks:
	- Implementation of ELF loader in the kernel
	- Discuss KV store (#1) in the next meeting

* 22-01-21 (scribe: Jinghao)
Thanks everyone for attending the meeting, it was an amazing discussion!

We talked about the following:
- Whether to move the ELF loader into the kernel: our conclusion is yes, as merely putting all the stuff from an ELF file into the kernel might make the data section executable and by moving the loader to the kernel it might save us from running into some nasty problems in the future
- Attacker & safety:
    - how shall we go with the threat model and should it be similar to eBPF?
    - What if an attacker loads some malicious assembly code into our framework? Idea: use a trusted compiler to sign the program (low priority)
    - safety issue for trusted users: probably adding some additional checks/restrictions -- depends on later observation (low priority)
- eBPF map support in Rust:
    - how to support them in Rust? Maybe perform some rewrite during the loading of ELF in the kernel
- kernel API and internal headers:
    - support api headers in Rust: https://github.com/rust-lang/rust-bindgen is a good way to go
    - eBPF programs using internal kernel headers: needs to inspect more eBPF programs

Next Steps:
- make ELF great again -- some progress on the in-kernel loader
- Gather an ordered list of which eBPF program we want to do first or last
